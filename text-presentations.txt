___ВСТУПЛЕНИЕ ОПРЕДЕЛЕНИЕ___
Что же это такое эта хеш-таблица?

Одно из определений гласит следующее:
Хеш-таблица это структура данных, реализующая интерфейс ассоциативного массива.Представляет собой эффективную структуру данных для реализации словарей, а именно, она позволяет хранить пары (ключ, значение) и выполнять три операции: операцию добавления новой пары, операцию поиска и операцию удаления пары по ключу.

___МАССИВЫ И СВЯЗНЫЕ СПИСКИ___
Но перед тем, как мы подробнее рассмотрим хеш-таблицы, давайте рассмотрим преимущества и недостатки простейших структур данных
|
типа массивов и связных списков.
|
Массивы как структура данных позволяет последовательно сохранять элементы. Каждый элемент связан с индексом, поэтому мы имеем произвольный доступ к элементу данного массива.
|
Отнесём произвольный доступ к элементам к преимуществу.
Но у массива есть минус: фиксированный размер. Т.е. из-за того, что массивы при сохранении данных размещают их в памяти последовательно, то вы должны при создании указать его размер. Фактически мы просим зарезервировать часть памяти для массива, не существует гарантии, что близлежащая память, будет доступна для использования. Из-за этого массивы не могут изменять свой размер.
|
Теперь про связные списки - они могут увеличиваться, т.к. их элементы могут находится в разных блоках памяти, каждый узел связного списка вмещает в себя элемент, который мы хотим сохранить, а также указатель на следующий узел 
|
однако цена, которую мы платим за возможность изменения размера списка это потеря произвольного доступа к элементам. Что бы получить доступ к определённому элементу, нужно пройти весь список до тех пор, пока не достигнем нужного нам результата. В худшем случае мы получим O(n), что показывает не хорошую эффективность.
|
А теперь давайте у этих структур выделим плюсы.
Массивы - произвольный доступ к элементам.
Связные списки - могут увеличиваться.
Но есть ли что-то, чтобы получить эти два преимущества? Конечно есть - хеш-таблицы.

___ИСПОЛЬЗОВАНИЕ ХЕШ-ТАБЛИЦ___
Хеш-таблицы используются, когда нужно быстро добавлять, удалять или искать элементы.
|
Использование хеш-таблиц:
|
+ Телефонная книга в телефоне. Она должна поддерживать добавление, поиск и удаление элементов. И с этим идеально справляется хеш-таблица.
+ Например мы хотим перейти на сайт с названием site.com, и мы должны преобразовать имя в IP-адрес. Т.е. связываем симвоическое имя с IP-адресом. Идеальная задача для хеш-таблиц! Это называется преобразованием DNS.
+ Использование хеш-таблицы как кэша (кэширование)
+ Исключение дубликатов

Сразу скажу про недостаток хеш-таблицы: плохой порядок или сортировка данных. Т.е. мы используем хеш-таблицы в том случае, если нас не волнуют будут ли отсортированы данные.

___ХЕШ-ФУНКЦИЯ 1___
Хеш-таблица по простому это массив, который работает в сочетании с хеш-функцией.
|
В научной терминологии говорят, что хеш-функция отображает строки на числа.
Хеш-функция получает на вход ключ а на выходе число, которое называем хеш-значение.
|
Хеш значение привязывает наш ключ к определённому индексу хеш-таблицы.
О хеш-функции мы поговорим через несколько минут, а пока просто представьте, что хеш-функция это некий чёрный ящик, который делает то, что я описал. 
Т.е. ещё раз что мы делаем? Используем хеш-функцию, чтобы определить где именно в хеш-таблице будет сохранён определённый ключ.
Эту же функцию мы используем и для поиска сохранённого нами ключа.
Пример:
|
[рассказываю]
Возможно вы уже видите тут проблему. Если нет, то я покажу. Допустим по причине того, что у нас так работает хеш функция, мы добавляем ant, а хеш-функция нам возвращает такой хеш, который существует. - Это пример коллизии, и она возникает, когда результат двух ключей, хешируется с одинаковым индексом. Даже, если мы напишем очень хорошую функцию, то в ней всё равно может быть несколько коллизий, и поэтому понадобится метод разрешения коллизий. 

___КОЛЛИЗИЯ___
Коллизия

Существует 2 основных варианта её решения.
открытая адресация и метод цепочек

1ый метод решения коллизии - это открытая адресация. Если ключ хешируется с тем же индексом, что и ранее сохранённый ключ, тогда он размещается в следующем свободном слоте данной хеш-таблицы. (показать как).

Но выбирая такой метод, вероятность очередной коллизии возрастает. Эта особенность называется кластеризацией. И это существенный недостаток этого метода разрешения коллизии. + время выполнения операции поиска, удаления и добавления может быть равно O(n), т.к. ближайший свободный слот может быть последним.

2ой метод решения коллизии - метод цепочек. При этом методе, наша хеш-таблица становится массивом указателей на связные списки. Т.е. если возникает коллизия, ключ может добавится в начало соответствующего связного списка. Что если мы будем искать 'apple', в худшем случае нам придётся пройти весь связный список. Поэтому время на поиск в хеш-таблице, который использует метод цепочек равно O(n/k) где k это размер хеш-таблицы. Но получается k - константа, и мы её отбрасываем и получаем всю то же O(n).

И в итоге что же лучше? На практике всё же второй метод предпочтительнее т.к. O(n/k) может иметь лучшую скорость выполнения.

___БЫСТРОДЕЙСТВИЕ___
Ещё немного о быстродействии:

Средний случай у хеш-таблицы O(1), и это очень хорошо, т.к. мы не зависим от длинны этого массива, и можем хранить большую хеш-таблицы(также как и в массиве). 1 элемент или 1000 разницы в поиске не будет. Но в худшем случае O(n) и это медленно.
Посмотрите на средний случай для хеш-таблиц. При поиске хеш-таблицы не уступают в скорости массивам(получение значения по индексу). А при вставке и удалении они так же быстры как и связные списки. Это одно из доказательств что хеш-таблицы взяли лучшее от обеих структур. Но в худшем случае хеш-таблицы медленно выполняют все эти операции, поэтому важно избегать худшего случая быстродействия при работе с хеш-таблицами. А для этого следует избегать коллизий. 

Для предотвращения коллизий необходимы:
Хорошая хеш-функция
Низкий коэффициент заполнения

___ХЕШ-ФУНКЦИЯ 2___
Как вы заметили, разрешение коллизий приводит к тому или иному типу линейного поиска, который значительно замедляет поиск. Поэтому мы должны находить такую хеш-функцию, которая минимизирует шанс возникновения коллизии.
Так какая же должна быть эта идеальная хеш-функция?

+ Она должна быть детерминирована (последовательна). При одинаквых входных параметрах, должны быть одинаковые возвращаемые значения.

+ Она должна использовать всю информацию о ключе, чтобы максимизировать количество возможных хеш-значений. Например у нас есть слово cat и catalog, логично их положить в разные места таблицы, если хеш-функция будет использовать только 1, 2 или даже 3 буквы слова для местаположения индекса, то у нас возникнет коллизия, т.к. оба слова начинаются с одинаковых трёх букв, а если таких слов будет больше, то шанс коллизии сильно возрастает.

+ Хеш-значения должны быть равномерно распрделены в таблице, это уменьшит длинну связных списков при коллизии

+ ???Хорошо будет если функция будет создавать различные хеш-значения для похожих ключей 
Есть ещё одна вещь для предотвращении коллизий.
Сейчас мы поговорим о коэффициенте заполнения:

___КОЭФФИЦИЕНТ ЗАПОЛНЕНИЯ___
Он вычисляется по формуле количество существующих элементов в хеш-таблице / общее количество элементов.
По коэффициенту заполнения можно оценить количество пустых ячеек в хеш-таблице.
Коэффициент больше 1 значит, что кол-во товаров превышает количество элементов в массиве, и нам приходится изменять размер таблицы. С меньшим коэффициентом число коллизий уменьшается и таблица работает более эффективно. Хорошее правило, если коэффициент больше 0,7 значит время увеличивать таблицу

___ИМПЛЕМЕНТАЦИЯ НА JS___
А давайте напишем хеш-таблицу на JS!

___Итоги___
+ Хеш-таблицы обеспечивают быстрое выполнение поиска, вставки и удаления 
+ Хеш-таблица создаётся объединением хеш-функции с массивом. И взяла всё лучше у массива и связного списка.
+ Коллизии не желательны. Хеш-функция должна быть подобрана правильно их свести количество коллизий к минимуму.
+ Как только коэффициент заполнения превышает 0.7, пора изменять размер хеш-таблицы
+ Хе-таблицы хорошо подходят для обноружения дубликатов, используются для кэширования данных.


___END___

(можно добавить задачки интерактивчик)